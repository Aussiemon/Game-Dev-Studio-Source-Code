shaders.horizontalShadowBlend = love.graphics.newShader("\textern vec2 res;\n\textern Image sampleBuffer;\n\textern int SAMPLE_COUNT = 10;\n\textern float STEP_SIZE = 1.5;\n\textern float SCALEX = 1.0;\n\t\n\tvarying float stepX;\n\t\n\t#ifdef VERTEX \n\t\tvec4 position( mat4 transform_projection, vec4 vertex_position )\n\t\t{\n\t\t\tstepX = STEP_SIZE / res.x * SCALEX;\n\t\t\t\n\t\t\treturn transform_projection * vertex_position;\n\t\t}\n\t#endif\n\t\n\t// RED channel is FLOOR\n\t// GREEN channel is WALL\n\t// BLUE = sampled GREEN in all directions * ceil(RED)\n\t\n\t#ifdef PIXEL\n\t\tvec4 effect(vec4 color, Image canvas, vec2 textureCoords, vec2 pixelCoordinates)\n\t\t{\n\t\t\tvec4 original = Texel(sampleBuffer, textureCoords);\n\t\t\t\n\t\t\tif (original.a == 0.0) {\n\t\t\t\treturn original; // if alpha is full zero, don't do anything here because there's nothing here\n\t\t\t}\n\t\t\t\n\t\t\tfloat shadowIntensity = 0.0;\n\t\t\tfloat x = textureCoords.x;\n\t\t\tfloat y = textureCoords.y;\n\t\t\t\n\t\t\t// in the first shader we blur the shadows horizontally\n\t\t\tfor (int i = -SAMPLE_COUNT; i <= SAMPLE_COUNT; i++)\n\t\t\t{\n\t\t\t\tvec2 samplePos = vec2(x + stepX * i, y);\n\t\t\t\tvec4 sample = Texel(sampleBuffer, samplePos);\n\t\t\t\t\n\t\t\t\tshadowIntensity += ceil(sample.g) * sample.a * (SAMPLE_COUNT - abs(float(i))); // ceil alpha, because if there is a floor then it must always be at 100%\n\t\t\t}\n\t\t\t\n\t\t\tshadowIntensity = shadowIntensity / (SAMPLE_COUNT * SAMPLE_COUNT);\n\t\t\t\n\t\t\treturn vec4(original.r, original.g, shadowIntensity, original.a);\n\t\t}\n\t#endif\n")
shaders.verticalShadowBlend = love.graphics.newShader("\textern vec2 res;\n\textern int SAMPLE_COUNT = 10;\n\textern float STEP_SIZE = 1.5;\n\textern float SHADOW_DARKNESS_SCALE = 0.6;\n\textern float SCALEY = 1.0;\n\t\n\tvarying float stepY;\n\t\n\t#ifdef VERTEX \n\t\tvec4 position(mat4 transform_projection, vec4 vertex_position)\n\t\t{\n\t\t\tstepY = STEP_SIZE / res.y * SCALEY;\n\t\t\t\n\t\t\treturn transform_projection * vertex_position;\n\t\t}\n\t#endif\n\t\n\t// here we will do the same sampling, but we will apply the final value to the alpha channels, and set the RGB channels to 0 (full black)\n\t\n\t#ifdef PIXEL\n\t\tvec4 effect(vec4 color, Image canvas, vec2 textureCoords, vec2 pixelCoordinates)\n\t\t{\n\t\t\tfloat shadowIntensity = 0.0;\n\t\t\tfloat x = textureCoords.x;\n\t\t\tfloat y = textureCoords.y;\n\t\t\t\n\t\t\t// in the second shader we compute the final intensity of the shadow and spread it to all channels (set rgb to 0, and apply final value to the alpha channel)\n\t\t\tfor (int i = -SAMPLE_COUNT; i <= SAMPLE_COUNT; i++)\n\t\t\t{\n\t\t\t\tvec2 samplePos = vec2(x, y + stepY * i);\n\t\t\t\tvec4 sample = Texel(canvas, samplePos);\n\t\t\t\t\n\t\t\t\tshadowIntensity += sample.b * sample.a * (SAMPLE_COUNT - abs(float(i))); // ceil alpha, because if there is a floor then it must always be at 100%\n\t\t\t}\n\t\t\t\n\t\t\tshadowIntensity = shadowIntensity / (SAMPLE_COUNT * SAMPLE_COUNT);\n\t\t\t\n\t\t\treturn vec4(0.0, 0.0, 0.0, Texel(canvas, textureCoords).a * shadowIntensity * SHADOW_DARKNESS_SCALE);\n\t\t}\n\t#endif\n")
