shaders.buildingShadowShader = love.graphics.newShader("\t//extern vec2 res;\n\textern Image maskBuffer;\n\textern float stepX, stepY;\n\textern float STEP_SIZE = 50;\n\textern float OFFSET = 50;\n\t\n\t//varying float offX, offY;\n\t\n\t#ifdef VERTEX \n\t\tvec4 position( mat4 transform_projection, vec4 vertex_position )\n\t\t{\n\n\t\t\treturn transform_projection * vertex_position;\n\t\t}\n\t#endif\n\t\n\t#ifdef PIXEL\n\t\tvec4 effect(vec4 color, Image canvas, vec2 textureCoords, vec2 pixelCoordinates)\n\t\t{\n\t\t\t// figure out the sample direction\n\t\t\tfloat x = textureCoords.x;\n\t\t\tfloat y = textureCoords.y;\n\t\t\t\n\t\t\tvec4 curPos = Texel(maskBuffer, textureCoords);\n\t\t\t\n\t\t\tif (curPos.r > 0.0 && curPos.a > 0.0) {\n\t\t\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int step = 0; step < STEP_SIZE; step++) {\n\t\t\t\tvec4 sampled = Texel(maskBuffer, vec2(x + stepX * step, y + stepY * step));\n\t\t\t\t\n\t\t\t\tif (sampled.r > 0.0) {\n\t\t\t\t\tfloat clr = 0.4 + 0.2 * (step / STEP_SIZE);\n\t\t\t\t\t\n\t\t\t\t\treturn vec4(clr, clr, clr, 1.0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t\t}\n\t#endif\n")
